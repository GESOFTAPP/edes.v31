# DBSerial

## Descripción General

La directiva **DBSerial** define un campo como serial o autoincremental en la tabla especificada por la etiqueta **[DBTable]**. Esta directiva es fundamental para la generación automática de identificadores únicos en registros de base de datos.

## Sintaxis

```
[DBSerial] Campo [ | Secuencia ]
```

### Parámetros

- **Campo**: Nombre del campo en la tabla de la base de datos que será serial/autoincremental
- **Secuencia**: *(Opcional)* Para Oracle, especifica el manejo de la secuencia asociada

## Funcionamiento por Motor de Base de Datos

### Oracle
Para el gestor Oracle, el sistema maneja secuencias automáticamente:

#### Comportamiento por Defecto
- **Creación automática**: Si se marca un campo como "serial" en el CREATE TABLE
- **Nomenclatura**: Usa el prefijo `sq` + nombre de la tabla
- **Ejemplo**: Para tabla `usuarios` → secuencia `sq_usuarios`

#### Opciones de Secuencia
- **Secuencia específica**: Proporcionar el nombre de una secuencia existente
- **NO**: Los seriales serán generados por triggers de base de datos
- **Configuración global**: Variable `$_DBSEQUENCE` en archivo `sql.ini`

### Otros Motores
Para MySQL, PostgreSQL, SQL Server, etc., utiliza las características nativas de autoincremento.

## Casos de Uso

### Configuración Básica
```
[DBTable] clientes
[DBSerial] id_cliente
```
Genera automáticamente IDs únicos para la tabla clientes.

### Oracle con Secuencia Personalizada
```
[DBTable] productos
[DBSerial] codigo_producto | seq_productos_especial
```
Utiliza una secuencia específica en lugar de la automática.

### Oracle con Triggers
```
[DBTable] facturas
[DBSerial] numero_factura | NO
```
Los números de factura serán generados por triggers personalizados.

### Configuración Global Oracle
```ini
# En archivo sql.ini
$_DBSEQUENCE = seq_global_sistema
```

## Integración con Otras Directivas

### Con DBTable y Fields
```
[DBTable] pedidos
[DBSerial] id_pedido
[Fields]
ID | id_pedido | 0 | H | 10 | | | AUTO | |
Fecha | fecha_pedido | 0 | T | | | Q | | |
Cliente | id_cliente | 0 | S | | | Q | | |
```

### Con DBSequence (Oracle)
```
[DBTable] documentos
[DBSerial] numero_documento
[DBSequence] seq_documentos_2024
```

## Características por Motor

### MySQL
```sql
CREATE TABLE usuarios (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100)
);
```

### PostgreSQL
```sql
CREATE TABLE usuarios (
    id SERIAL PRIMARY KEY,
    nombre VARCHAR(100)
);
```

### Oracle
```sql
CREATE TABLE usuarios (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(100)
);

-- O con secuencia tradicional
CREATE SEQUENCE sq_usuarios START WITH 1 INCREMENT BY 1;
```

### SQL Server
```sql
CREATE TABLE usuarios (
    id INT IDENTITY(1,1) PRIMARY KEY,
    nombre NVARCHAR(100)
);
```

## Mejores Prácticas

### Nomenclatura
- **Consistencia**: Usar el mismo patrón para campos seriales
- **Descriptivo**: Nombres que identifiquen claramente el propósito
- **Convenciones**: Seguir estándares del equipo de desarrollo

### Configuración
- **Tipo de dato**: Usar INTEGER o BIGINT según el volumen esperado
- **Índices**: Los campos seriales suelen ser clave primaria
- **Rangos**: Considerar el rango máximo del tipo de dato

### Oracle Específico
- **Secuencias vs Identity**: Evaluar cuál es más apropiado
- **Cache**: Configurar cache apropiado para rendimiento
- **Triggers**: Solo cuando se necesite lógica compleja

## Consideraciones Técnicas

### Rendimiento
- **Índices automáticos**: Los campos seriales suelen generar índices únicos
- **Concurrencia**: Los seriales están optimizados para acceso concurrente
- **Gaps**: Pueden existir saltos en la numeración (normal)

### Integridad
- **Unicidad**: Garantizada por el motor de base de datos
- **No reutilización**: Los valores eliminados no se reutilizan
- **Consistencia**: Mantienen orden cronológico aproximado

## Configuración Avanzada Oracle

### Secuencia con Configuración Específica
```sql
CREATE SEQUENCE sq_pedidos
    START WITH 1000
    INCREMENT BY 1
    MAXVALUE 999999999
    CACHE 20
    NOCYCLE;
```

### Trigger para Lógica Compleja
```sql
CREATE OR REPLACE TRIGGER trg_facturas_serial
    BEFORE INSERT ON facturas
    FOR EACH ROW
BEGIN
    IF :NEW.numero_factura IS NULL THEN
        -- Lógica personalizada para numeración
        SELECT TO_NUMBER(TO_CHAR(SYSDATE, 'YYYY')) * 1000000 + 
               seq_facturas.NEXTVAL 
        INTO :NEW.numero_factura 
        FROM dual;
    END IF;
END;
```

## Migración y Mantenimiento

### Resetear Secuencia
```sql
-- Oracle: Ajustar secuencia al máximo existente
ALTER SEQUENCE sq_tabla 
RESTART START WITH (SELECT NVL(MAX(id), 0) + 1 FROM tabla);
```

### Verificar Estado
```sql
-- Oracle: Consultar secuencias
SELECT sequence_name, last_number, increment_by, cache_size
FROM user_sequences
WHERE sequence_name LIKE 'SQ_%';

-- MySQL: Consultar AUTO_INCREMENT
SHOW TABLE STATUS LIKE 'tabla_name';

-- PostgreSQL: Consultar secuencias
SELECT sequence_name, last_value 
FROM information_schema.sequences;
```

## Solución de Problemas

### Errores Comunes

1. **Valor duplicado**
   - Verificar que el campo esté correctamente configurado como serial
   - En Oracle, revisar que la secuencia no esté desincronizada

2. **Secuencia no encontrada (Oracle)**
   - Verificar que la secuencia exista
   - Comprobar permisos de acceso

3. **Rendimiento lento en inserciones**
   - Revisar configuración de cache en secuencias
   - Evaluar contención en secuencias muy utilizadas

### Comandos de Diagnóstico
```sql
-- Oracle: Próximo valor de secuencia
SELECT sq_tabla.NEXTVAL FROM dual;

-- MySQL: Información de AUTO_INCREMENT
SELECT AUTO_INCREMENT 
FROM information_schema.TABLES 
WHERE TABLE_NAME = 'tabla_name';

-- PostgreSQL: Valor actual de secuencia
SELECT last_value FROM tabla_id_seq;
```

## Relación con Otras Directivas

- **[DBTable]**: Define la tabla donde aplicar el serial
- **[DBSequence]**: Configura el manejo específico en Oracle
- **[Fields]**: Define cómo se presenta el campo en formularios
- **[DBIndex]**: Los campos seriales suelen tener índices automáticos